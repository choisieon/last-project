<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>최고로 정교한 픽셀아트 지도</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #2e3a47; /* Dark but warm background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: auto; /* Allow scrolling */
        }
        .pixel-grid {
            display: grid;
            border-radius: 10px; /* Rounded corners */
            overflow: hidden; /* For rounded corners to apply */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5); /* Shadow effect */
            background-color: #405467; /* Grid background color */
            padding: 20px; /* Add padding */
            position: relative; /* For canvas positioning */
        }
        canvas {
            display: block;
            background-color: #212F3D; /* Canvas background color (warmer dark blue) */
            border-radius: 8px; /* Canvas rounded corners */
        }
        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.8em;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            transform: translate(-50%, -110%);
            white-space: nowrap;
            z-index: 10;
        }
        .tooltip.active {
            opacity: 1;
        }
    </style>
</head>
<body class="p-4">
    <div class="pixel-grid">
        <canvas id="pixelCanvas"></canvas>
        <div id="tooltip" class="tooltip"></div>
    </div>

    <script>
        const canvas = document.getElementById('pixelCanvas');
        const ctx = canvas.getContext('2d');
        const tooltip = document.getElementById('tooltip');

        const PIXEL_SIZE = 2; // Much smaller pixel size for extreme detail
        const GRID_WIDTH = 400; // Increased grid dimensions
        const GRID_HEIGHT = 300;

        canvas.width = GRID_WIDTH * PIXEL_SIZE;
        canvas.height = GRID_HEIGHT * PIXEL_SIZE;

        // Refined color palette based on reference image tones (more muted, earthy, detailed)
        const colors = {
            // Background/Sky
            skyDeep: '#2C3A40',
            skyLight: '#4F6C7A',
            cloudsLight: '#AABBC2', // For subtle cloud effects

            // Terrain
            grassMain: '#4D735C',
            grassDark: '#3A5B49',
            dirtBrown: '#7A5B4C',
            pathGray: '#6A6F6D',
            pathLightGray: '#8A8F8D',
            pathOutline: '#5A5F5D', // Darker outline for paths

            // Water
            waterDeep: '#2F5C6A',
            waterHighlight: '#4B889C',
            waterOutline: '#204C5A', // Darker outline for water

            // Lights/Stars/Accents
            lightGlow: '#F5DEB3', // Muted yellow/cream
            accentRed: '#D24B4B', // Muted red for flags, some details
            accentBlue: '#5B9DD9', // Brighter blue for some accents

            // Building Colors (more nuanced and varied)
            buildingCream: '#D4C49F', // For the grand building (Gu-jik Junbigi)
            buildingBrownRoof: '#8C6C5A', // Roof for grand building
            buildingBrownTrim: '#A8926D', // Trim/details for grand building
            buildingOutline: '#3A4B5C', // General building outline

            buildingGrayModern: '#7A8C9C', // For modern office (Cho-gi Chwi-eopgi)
            buildingGrayDark: '#5E6F7D', // Darker parts of modern office
            buildingGlassDark: '#4A6070', // Darker glass
            buildingGlassLight: '#9FBAC8', // Lighter glass reflection

            buildingLibraryMain: '#6A8B99', // Muted blue-grey for library (Jin-ro Tam-saekgi)
            buildingLibraryRoof: '#50707D', // Darker roof for library
            buildingLibraryBooks: '#A05C3A', // Bookshelves detail

            buildingHouseMain: '#C8A08C', // Warm beige for houses (Saeng-hwal Gi-ban Ma-ryeon-gi)
            buildingHouseRoof: '#A06B5A', // Reddish brown for house roofs
            buildingHouseChimney: '#7A5B4C', // Chimney
            buildingHouseAccent: '#B08C7A', // House trim

            buildingCommunityMain: '#9CBBC2', // Light blue-grey for community (Ga-jok Hyeong-seong-gi)
            buildingCommunityRoof: '#7A9AA0', // Darker roof for community

            buildingAcademyMain: '#8C8C8C', // Medium grey for academy (Ja-gi Gye-bal/I-jik-gi)
            buildingAcademyAccent: '#B0B0B0', // Lighter grey for academy details

            doorWood: '#6B4C3E', // Dark wood doors
            doorMetal: '#8C8C8C', // Metal doors

            // Natural elements
            treeCanopyLight: '#6B997A', // Lighter tree canopy
            treeCanopyDark: '#4D735C', // Darker tree canopy
            treeTrunkBrown: '#5A4A3C', // Tree trunk

            // Flowers
            flowerPink: '#E06F8C',
            flowerOrange: '#FF9E6F',

            // Playground
            slideRed: '#D24B4B',
            slideYellow: '#F5DEB3',
            swingWood: '#7A5B4C',
            swingMetal: '#8C8C8C',
            sandColor: '#D4C49F',

            // Fence
            fenceWood: '#8C6C5A',

            // Character
            characterOrange: '#FF7043' // Character color
        };

        // Map grid initialization: Store tile types for collision detection
        const mapGrid = Array(GRID_WIDTH).fill(0).map(() => Array(GRID_HEIGHT).fill('grass'));

        // Function to draw a single pixel: Updates map grid
        function drawPixel(x, y, color, type = 'grass') {
            if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT) {
                ctx.fillStyle = color;
                ctx.fillRect(x * PIXEL_SIZE, y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
                mapGrid[x][y] = type; // Store tile type in map grid
            }
        }

        // Function to fill a specific area with color: Updates map grid
        function fillRect(x, y, width, height, color, type = 'grass') {
            for (let i = x; i < x + width; i++) {
                for (let j = y; j < y + height; j++) {
                    drawPixel(i, j, color, type);
                }
            }
        }

        // Function to draw a detailed outline around a filled rectangle
        function drawOutline(x, y, width, height, outlineColor) {
            // Top and Bottom
            fillRect(x, y, width, 1, outlineColor, 'outline');
            fillRect(x, y + height - 1, width, 1, outlineColor, 'outline');
            // Left and Right
            fillRect(x, y, 1, height, outlineColor, 'outline');
            fillRect(x + width - 1, y, 1, height, outlineColor, 'outline');
        }


        // Draw overall background (night sky and grass)
        function drawBackground() {
            // Sky (top 1/3)
            fillRect(0, 0, GRID_WIDTH, Math.floor(GRID_HEIGHT / 3), colors.skyDeep, 'sky');
            // Grass (bottom 2/3)
            fillRect(0, Math.floor(GRID_HEIGHT / 3), GRID_WIDTH, GRID_HEIGHT - Math.floor(GRID_HEIGHT / 3), colors.grassMain, 'grass');

            // Draw more stars (static)
            for (let i = 0; i < 1500; i++) { // Even more stars
                const x = Math.floor(Math.random() * GRID_WIDTH);
                const y = Math.floor(Math.random() * Math.floor(GRID_HEIGHT / 3));
                drawPixel(x, y, colors.lightGlow, 'sky'); // Always draw
            }

            // Add dark parts to grass (texture)
            for (let i = 0; i < GRID_WIDTH; i++) {
                for (let j = Math.floor(GRID_HEIGHT / 3); j < GRID_HEIGHT; j++) {
                    if (Math.random() < 0.25) { // Increased texture probability
                        drawPixel(i, j, colors.grassDark, 'grass');
                    }
                }
            }
        }

        const buildings = []; // Array to store building positions and names for tooltips

        // Tree drawing function (more detailed)
        function drawTree(x, y, name) {
            const trunkHeight = Math.floor(Math.random() * 8) + 12; // 12-19 pixels
            const canopyHeight = Math.floor(Math.random() * 6) + 14; // 14-19 pixels
            const canopyWidth = Math.floor(Math.random() * 8) + 16; // 16-23 pixels, centered

            const trunkX = x + Math.floor(canopyWidth / 2) - 2; // Wider trunk

            // Trunk
            fillRect(trunkX, y + canopyHeight, 4, trunkHeight, colors.treeTrunkBrown, 'landscape');
            drawOutline(trunkX, y + canopyHeight, 4, trunkHeight, colors.buildingOutline);

            // Canopy (more complex shape)
            fillRect(x, y + 2, canopyWidth, canopyHeight - 2, colors.treeCanopyLight, 'landscape'); // Main body
            fillRect(x + 2, y, canopyWidth - 4, 4, colors.treeCanopyLight, 'landscape'); // Top part
            fillRect(x + Math.floor(canopyWidth * 0.1), y + Math.floor(canopyHeight * 0.1), Math.floor(canopyWidth * 0.8), Math.floor(canopyHeight * 0.8), colors.treeCanopyDark, 'landscape'); // Inner dark
            drawOutline(x, y + 2, canopyWidth, canopyHeight - 2, colors.buildingOutline);
            drawOutline(x + 2, y, canopyWidth - 4, 4, colors.buildingOutline);

            buildings.push({ x, y, width: canopyWidth, height: canopyHeight + trunkHeight, name });
        }

        // Flower patch
        function drawFlowerPatch(x, y, color1, color2, name) {
            const patchSize = Math.floor(Math.random() * 3) + 4; // 4-6 flowers
            for (let i = 0; i < patchSize; i++) {
                const fx = x + Math.floor(Math.random() * 5);
                const fy = y + Math.floor(Math.random() * 5);
                drawPixel(fx, fy, (Math.random() > 0.5 ? color1 : color2), 'landscape'); // Flower head
                drawPixel(fx, fy + 1, colors.grassMain, 'landscape'); // Stem
            }
            buildings.push({ x, y, width: 5, height: 6, name: name || '꽃밭' });
        }

        // Bench
        function drawBench(x, y, name) {
            const benchWidth = 12;
            const benchHeight = 4;
            fillRect(x, y, benchWidth, benchHeight, colors.dirtBrown, 'landscape'); // Seat
            fillRect(x + 1, y + benchHeight, 2, 4, colors.treeTrunkBrown, 'landscape'); // Leg 1
            fillRect(x + benchWidth - 3, y + benchHeight, 2, 4, colors.treeTrunkBrown, 'landscape'); // Leg 2
            drawOutline(x, y, benchWidth, benchHeight, colors.buildingOutline);
            buildings.push({ x, y, width: benchWidth, height: benchHeight + 4, name: name || '벤치' });
        }

        // Lamppost
        function drawLamppost(x, y, name) {
            const poleHeight = 20;
            fillRect(x, y, 2, poleHeight, colors.lightGray, 'landscape'); // Pole
            drawOutline(x, y, 2, poleHeight, colors.buildingOutline);

            fillRect(x - 4, y, 10, 2, colors.lightGray, 'landscape'); // Top crossbar
            drawOutline(x - 4, y, 10, 2, colors.buildingOutline);

            fillRect(x - 2, y - 4, 6, 4, colors.lightGlow, 'landscape'); // Light source
            drawOutline(x - 2, y - 4, 6, 4, colors.buildingOutline);
            buildings.push({ x, y, width: 10, height: poleHeight + 4, name: name || '가로등' });
        }

        // Fence segment (vertical posts)
        function drawFence(x, y, length, orientation, name) { // orientation: 'horizontal' or 'vertical'
            const postWidth = 2;
            const postHeight = 6;
            const railHeight = 2;
            const railOffset = 2;

            if (orientation === 'horizontal') {
                for (let i = 0; i <= length; i += 6) { // Posts every 6 pixels
                    fillRect(x + i, y, postWidth, postHeight, colors.fenceWood, 'fence');
                }
                fillRect(x, y + railOffset, length + postWidth, railHeight, colors.fenceWood, 'fence'); // Top rail
                fillRect(x, y + postHeight - railHeight - 1, length + postWidth, railHeight, colors.fenceWood, 'fence'); // Bottom rail
            } else { // vertical
                for (let i = 0; i <= length; i += 6) {
                    fillRect(x, y + i, postHeight, postWidth, colors.fenceWood, 'fence');
                }
                fillRect(x + railOffset, y, railHeight, length + postWidth, colors.fenceWood, 'fence');
                fillRect(x + postHeight - railHeight - 1, y, railHeight, length + postWidth, colors.fenceWood, 'fence');
            }
            buildings.push({ x, y, width: orientation === 'horizontal' ? length + postWidth : postHeight, height: orientation === 'vertical' ? length + postWidth : postHeight, name: name || '울타리' });
        }


        // Building drawing functions (more detailed)
        // Building Type A: Gu-jik Junbigi (Grand, school-like)
        function drawBuildingTypeA(x, y, name) {
            const width = 72; // 36 * 2
            const height = 60; // 30 * 2
            fillRect(x, y, width, height, colors.buildingCream, 'building'); // Main body
            drawOutline(x, y, width, height, colors.buildingOutline);

            // Roof
            fillRect(x, y - 8, width, 8, colors.buildingBrownRoof, 'building');
            drawOutline(x, y - 8, width, 8, colors.buildingOutline);
            fillRect(x + 8, y - 16, width - 16, 8, colors.buildingBrownRoof, 'building'); // Upper roof
            drawOutline(x + 8, y - 16, width - 16, 8, colors.buildingOutline);
            drawPixel(x + Math.floor(width / 2), y - 20, colors.buildingBrownRoof, 'building'); // Peak

            // Columns/Facade detail
            for (let i = 0; i < 5; i++) { // 5 columns
                fillRect(x + 6 + i * 14, y + 10, 4, 40, colors.buildingBrownTrim, 'building');
                drawOutline(x + 6 + i * 14, y + 10, 4, 40, colors.buildingOutline);
            }

            // Windows with frames
            for (let i = 0; i < 4; i++) {
                fillRect(x + 10 + i * 14, y + 16, 10, 12, colors.buildingGlassLight, 'building'); // Top row
                drawOutline(x + 10 + i * 14, y + 16, 10, 12, colors.buildingOutline);
                fillRect(x + 10 + i * 14, y + 36, 10, 12, colors.buildingGlassLight, 'building'); // Bottom row
                drawOutline(x + 10 + i * 14, y + 36, 10, 12, colors.buildingOutline);
            }

            // Main entrance with steps
            fillRect(x + Math.floor(width / 2) - 8, y + height - 20, 16, 20, colors.doorWood, 'building');
            drawOutline(x + Math.floor(width / 2) - 8, y + height - 20, 16, 20, colors.buildingOutline);
            fillRect(x + Math.floor(width / 2) - 12, y + height, 24, 4, colors.pathLightGray, 'building'); // Steps
            drawOutline(x + Math.floor(width / 2) - 12, y + height, 24, 4, colors.buildingOutline);

            buildings.push({ x, y, width, height, name });
        }

        // Building Type B: Cho-gi Chwi-eopgi (Modern Office)
        function drawBuildingTypeB(x, y, name) {
            const width = 64; // 32 * 2
            const height = 80; // 40 * 2
            fillRect(x, y, width, height, colors.buildingGrayModern, 'building'); // Main body
            drawOutline(x, y, width, height, colors.buildingOutline);

            // Windows (grid-like, highly detailed with reflections)
            for (let row = 0; row < 18; row++) {
                for (let col = 0; col < 3; col++) {
                    const winX = x + 4 + col * 20;
                    const winY = y + 4 + row * 4;
                    fillRect(winX, winY, 12, 4, colors.buildingGlassDark, 'building'); // Darker glass
                    drawOutline(winX, winY, 12, 4, colors.buildingOutline);

                    fillRect(winX + 2, winY + 1, 8, 2, colors.buildingGlassLight, 'building'); // Light reflection
                }
            }

            // Entrance (tall glass entrance)
            fillRect(x + Math.floor(width / 2) - 12, y + height - 28, 24, 28, colors.buildingGlassDark, 'building');
            drawOutline(x + Math.floor(width / 2) - 12, y + height - 28, 24, 28, colors.buildingOutline);
            fillRect(x + Math.floor(width / 2) - 10, y + height - 26, 20, 24, colors.buildingGlassLight, 'building'); // Inner glass
            fillRect(x + Math.floor(width / 2) - 4, y + height - 12, 2, 10, colors.doorMetal, 'building'); // Handle left
            fillRect(x + Math.floor(width / 2) + 2, y + height - 12, 2, 10, colors.doorMetal, 'building'); // Handle right

            buildings.push({ x, y, width, height, name });
        }

        // Building Type C: Jin-ro Tam-saekgi (Library)
        function drawBuildingTypeC(x, y, name) {
            const width = 88; // 44 * 2
            const height = 56; // 28 * 2
            fillRect(x, y, width, height, colors.buildingLibraryMain, 'building'); // Main body
            drawOutline(x, y, width, height, colors.buildingOutline);

            fillRect(x, y - 4, width, 4, colors.buildingLibraryRoof, 'building'); // Flat roof
            drawOutline(x, y - 4, width, 4, colors.buildingOutline);

            // Large windows with interior shelves
            for (let i = 0; i < 5; i++) {
                const winX = x + 4 + i * 16;
                const winY = y + 12;
                fillRect(winX, winY, 12, 24, colors.buildingGlassDark, 'building');
                drawOutline(winX, winY, 12, 24, colors.buildingOutline);
                fillRect(winX + 2, winY + 4, 8, 4, colors.buildingLibraryBooks, 'building'); // Shelf 1
                fillRect(winX + 2, winY + 12, 8, 4, colors.buildingLibraryBooks, 'building'); // Shelf 2
                fillRect(winX + 2, winY + 20, 8, 4, colors.buildingLibraryBooks, 'building'); // Shelf 3
            }

            // Entrance
            fillRect(x + Math.floor(width / 2) - 8, y + height - 20, 16, 20, colors.doorWood, 'building');
            drawOutline(x + Math.floor(width / 2) - 8, y + height - 20, 16, 20, colors.buildingOutline);
            fillRect(x + Math.floor(width / 2) - 6, y + height - 18, 12, 16, colors.buildingGlassLight, 'building'); // Glass doors
            drawPixel(x + Math.floor(width / 2) - 2, y + height - 10, colors.lightGray, 'building'); // Handle
            drawPixel(x + Math.floor(width / 2) + 1, y + height - 10, colors.lightGray, 'building'); // Handle

            buildings.push({ x, y, width, height, name });
        }

        // Building Type D: Saeng-hwal Gi-ban Ma-ryeon-gi (Cozy House)
        function drawBuildingTypeD(x, y, name) {
            const width = 56; // 28 * 2
            const height = 48; // 24 * 2
            fillRect(x, y + 16, width, height - 16, colors.buildingHouseMain, 'building'); // House body
            drawOutline(x, y + 16, width, height - 16, colors.buildingOutline);

            // Roof (peaked, detailed tiles)
            fillRect(x - 8, y, width + 16, 12, colors.buildingHouseRoof, 'building');
            drawOutline(x - 8, y, width + 16, 12, colors.buildingOutline);
            for(let i=0; i < (width + 16)/4; i++){
                drawPixel(x-8 + i*4, y + 4, colors.buildingBrownTrim, 'building'); // Roof tiles
                drawPixel(x-8 + i*4 + 2, y + 8, colors.buildingBrownTrim, 'building');
            }
            drawPixel(x + Math.floor(width / 2), y - 4, colors.buildingHouseRoof, 'building'); // Peak

            // Chimney
            fillRect(x + width - 12, y + 4, 8, 16, colors.buildingHouseChimney, 'building');
            drawOutline(x + width - 12, y + 4, 8, 16, colors.buildingOutline);
            drawPixel(x + width - 8, y, colors.softOrange, 'building'); // Smoke/glow

            // Window with curtains
            fillRect(x + 8, y + 24, 16, 16, colors.windowGlass, 'building');
            drawOutline(x + 8, y + 24, 16, 16, colors.buildingOutline);
            fillRect(x + 8, y + 24, 4, 16, colors.buildingHouseAccent, 'building'); // Left curtain
            fillRect(x + 20, y + 24, 4, 16, colors.buildingHouseAccent, 'building'); // Right curtain
            drawPixel(x + 16, y + 32, colors.lightGray, 'building'); // Window handle

            // Door with porch
            fillRect(x + width - 20, y + height - 24, 16, 24, colors.doorWood, 'building');
            drawOutline(x + width - 20, y + height - 24, 16, 24, colors.buildingOutline);
            drawPixel(x + width - 8, y + height - 12, colors.lightGlow, 'building'); // Door handle
            fillRect(x + width - 24, y + height, 24, 4, colors.pathStone, 'building'); // Porch

            buildings.push({ x, y, width, height, name });
        }

        // Building Type E: Ga-jok Hyeong-seong-gi (Community Center/Family-oriented)
        function drawBuildingTypeE(x, y, name) {
            const width = 80; // 40 * 2
            const height = 52; // 26 * 2
            fillRect(x, y, width, height, colors.buildingCommunityMain, 'building'); // Main body
            drawOutline(x, y, width, height, colors.buildingOutline);

            fillRect(x, y - 4, width, 4, colors.buildingCommunityRoof, 'building'); // Roof
            drawOutline(x, y - 4, width, 4, colors.buildingOutline);

            for (let i = 0; i < 4; i++) {
                fillRect(x + 4 + i * 20, y + 8, 16, 12, colors.windowGlass, 'building'); // Large windows
                drawOutline(x + 4 + i * 20, y + 8, 16, 12, colors.buildingOutline);
                fillRect(x + 4 + i * 20, y + 28, 16, 12, colors.windowGlass, 'building'); // Second row
                drawOutline(x + 4 + i * 20, y + 28, 16, 12, colors.buildingOutline);
            }

            // Central entrance
            fillRect(x + Math.floor(width / 2) - 8, y + height - 20, 16, 20, colors.doorMetal, 'building');
            drawOutline(x + Math.floor(width / 2) - 8, y + height - 20, 16, 20, colors.buildingOutline);
            fillRect(x + Math.floor(width / 2) - 6, y + height - 18, 12, 16, colors.buildingGlassLight, 'building'); // Glass doors
            buildings.push({ x, y, width, height, name });
        }

        // Building Type F: Ja-gi Gye-bal/I-jik-gi (Modern Academy/Small Office)
        function drawBuildingTypeF(x, y, name) {
            const width = 72; // 36 * 2
            const height = 60; // 15 * 2
            fillRect(x, y, width, height, colors.buildingAcademyMain, 'building'); // Main body
            drawOutline(x, y, width, height, colors.buildingOutline);

            fillRect(x, y + 4, width, 4, colors.buildingAcademyAccent, 'building'); // Accent band
            drawOutline(x, y + 4, width, 4, colors.buildingOutline);

            for (let i = 0; i < 4; i++) {
                fillRect(x + 4 + i * 16, y + 12, 12, 12, colors.windowGlass, 'building'); // Windows
                drawOutline(x + 4 + i * 16, y + 12, 12, 12, colors.buildingOutline);
                fillRect(x + 4 + i * 16, y + 32, 12, 12, colors.windowGlass, 'building');
                drawOutline(x + 4 + i * 16, y + 32, 12, 12, colors.buildingOutline);
            }
            // Entrance
            fillRect(x + Math.floor(width / 2) - 8, y + height - 20, 16, 20, colors.doorMetal, 'building');
            drawOutline(x + Math.floor(width / 2) - 8, y + height - 20, 16, 20, colors.buildingOutline);
            fillRect(x + Math.floor(width / 2) - 6, y + height - 18, 12, 16, colors.buildingGlassLight, 'building');
            drawPixel(x + Math.floor(width / 2) - 4, y + 8, colors.lightGlow, 'building'); // Small light/logo
            drawPixel(x + Math.floor(width / 2) + 2, y + 8, colors.lightGlow, 'building');
            buildings.push({ x, y, width, height, name });
        }


        // Road drawing function (with more detail)
        function drawRoad(startX, startY, endX, endY) {
            const roadWidth = 10; // Pixels wide in grid units
            if (startX === endX) { // Vertical road
                for (let y = Math.min(startY, endY); y <= Math.max(startY, endY); y++) {
                    fillRect(startX, y, roadWidth, 1, colors.pathGray, 'road');
                    drawPixel(startX, y, colors.pathOutline, 'road'); // Left outline
                    drawPixel(startX + roadWidth - 1, y, colors.pathOutline, 'road'); // Right outline
                }
            } else if (startY === endY) { // Horizontal road
                for (let x = Math.min(startX, endX); x <= Math.max(startX, endX); x++) {
                    fillRect(x, startY, 1, roadWidth, colors.pathGray, 'road');
                    drawPixel(x, startY, colors.pathOutline, 'road'); // Top outline
                    drawPixel(x, startY + roadWidth - 1, colors.pathOutline, 'road'); // Bottom outline
                }
            }
        }

        // Draw suitable landscape elements (more detailed)
        function drawLandscapeElements() {
            // Trees
            drawTree(40, 80, '큰 나무');
            drawTree(240, 160, '큰 나무');
            drawTree(100, 200, '작은 나무');
            drawTree(280, 60, '나무');
            drawTree(180, 260, '나무'); // Added one more tree for density

            // Small patches of grass/hills
            fillRect(60, 144, 40, 20, colors.grassDark, 'grass');
            fillRect(200, 64, 32, 16, colors.grassDark, 'grass');
            fillRect(120, 112, 28, 12, colors.grassDark, 'grass');

            // Benches
            drawBench(72, 176, '쉼터 벤치');
            drawBench(250, 200, '공원 벤치');

            // Small ponds with lily pads and ripples
            fillRect(140, 80, 48, 32, colors.waterDeep, 'water');
            drawOutline(138, 78, 52, 36, colors.waterOutline); // Outline for pond
            drawPixel(148, 88, colors.waterRipple, 'water'); drawPixel(152, 92, colors.waterRipple, 'water');
            drawPixel(172, 100, colors.waterRipple, 'water'); drawPixel(176, 104, colors.waterRipple, 'water');
            drawPixel(156, 84, colors.treeCanopyLight, 'water'); drawPixel(160, 84, colors.treeCanopyLight, 'water'); // Lily pads
            drawPixel(164, 96, colors.treeCanopyLight, 'water');

            // Lampposts
            drawLamppost(160, 40, '가로등 1');
            drawLamppost(290, 120, '가로등 2');

            // Flowers
            drawFlowerPatch(88, 152, colors.flowerPink, colors.flowerOrange, '분홍/주황 꽃밭');
            drawFlowerPatch(220, 72, colors.flowerOrange, colors.flowerPink, '주황/분홍 꽃밭');

            // Stone paths
            fillRect(120, 100, 6, 2, colors.pathStone, 'landscape');
            fillRect(122, 102, 2, 6, colors.pathStone, 'landscape');
            fillRect(124, 106, 6, 2, colors.pathStone, 'landscape');

            // Playground (simplified detail from reference)
            const playgroundX = 200;
            const playgroundY = 180;
            const playgroundWidth = 50;
            const playgroundHeight = 30;
            fillRect(playgroundX, playgroundY, playgroundWidth, playgroundHeight, colors.sandColor, 'landscape'); // Sand area
            drawOutline(playgroundX, playgroundY, playgroundWidth, playgroundHeight, colors.buildingOutline);

            // Slide
            fillRect(playgroundX + 10, playgroundY + 10, 8, 4, colors.slideRed, 'landscape'); // Slide top
            fillRect(playgroundX + 10, playgroundY + 14, 2, 10, colors.slideRed, 'landscape'); // Slide vertical part
            fillRect(playgroundX + 12, playgroundY + 20, 10, 4, colors.slideYellow, 'landscape'); // Slide slope
            drawPixel(playgroundX + 22, playgroundY + 24, colors.slideYellow, 'landscape'); // Slide end

            // Swings
            fillRect(playgroundX + 30, playgroundY + 5, 2, 15, colors.swingMetal, 'landscape'); // Left pole
            fillRect(playgroundX + 40, playgroundY + 5, 2, 15, colors.swingMetal, 'landscape'); // Right pole
            fillRect(playgroundX + 30, playgroundY + 5, 12, 2, colors.swingMetal, 'landscape'); // Top bar
            fillRect(playgroundX + 33, playgroundY + 7, 2, 6, colors.swingWood, 'landscape'); // Swing seat left
            fillRect(playgroundX + 37, playgroundY + 7, 2, 6, colors.swingWood, 'landscape'); // Swing seat right
            buildings.push({ x: playgroundX, y: playgroundY, width: playgroundWidth, height: playgroundHeight, name: '놀이터' });

        }

        // Character object
        let character = {
            x: 72, // Initial grid X coordinate (on a road)
            y: 112, // Initial grid Y coordinate (on a road)
            color: colors.characterOrange, // Character color
            size: 5 // Character occupies 5x5 grid pixels (10x10 actual pixels)
        };

        // Character drawing function
        function drawCharacter() {
            fillRect(character.x, character.y, character.size, character.size, character.color, 'character');
        }

        // Key input tracking
        const pressedKeys = {};
        document.addEventListener('keydown', (e) => {
            pressedKeys[e.key] = true;
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
            }
        });
        document.addEventListener('keyup', (e) => {
            pressedKeys[e.key] = false;
        });

        // Check if character can move to target tile
        function isWalkable(x, y, charSize) {
            for (let dx = 0; dx < charSize; dx++) {
                for (let dy = 0; dy < charSize; dy++) {
                    const currentX = x + dx;
                    const currentY = y + dy;

                    if (currentX < 0 || currentX >= GRID_WIDTH || currentY < 0 || currentY >= GRID_HEIGHT) {
                        return false; // Out of bounds
                    }
                    if (mapGrid[currentX][currentY] !== 'road') {
                        return false; // Not a road tile
                    }
                }
            }
            return true;
        }

        let lastMoveTime = 0;
        const moveDelay = 50; // Faster movement due to higher resolution

        // Update character position based on key input
        function updateCharacterPosition(currentTime) {
            let moved = false;
            let targetX = character.x;
            let targetY = character.y;

            if (currentTime - lastMoveTime > moveDelay) {
                if (pressedKeys['ArrowUp']) {
                    targetY--;
                    moved = true;
                } else if (pressedKeys['ArrowDown']) {
                    targetY++;
                    moved = true;
                } else if (pressedKeys['ArrowLeft']) {
                    targetX--;
                    moved = true;
                } else if (pressedKeys['ArrowRight']) {
                    targetX++;
                    moved = true;
                }

                if (moved) {
                    if (isWalkable(targetX, targetY, character.size)) {
                        character.x = targetX;
                        character.y = targetY;
                        lastMoveTime = currentTime;
                    }
                }
            }
        }

        // Main map drawing function
        function drawMap() {
            // Re-initialize mapGrid as drawing functions will fill it
            for (let x = 0; x < GRID_WIDTH; x++) {
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    mapGrid[x][y] = 'grass';
                }
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas
            buildings.length = 0; // Clear buildings array for tooltips

            drawBackground();
            drawLandscapeElements();

            // Draw each building (6 spaces)
            // Positions adjusted for PIXEL_SIZE = 2 (original coords * 2)
            // Top row
            drawBuildingTypeA(32, 40, '구직 준비기'); // (16*2, 20*2)
            drawBuildingTypeB(120, 40, '초기 취업기'); // (60*2, 20*2)
            drawBuildingTypeC(220, 40, '진로 탐색기'); // (110*2, 20*2)
            // Bottom row
            drawBuildingTypeD(32, 140, '생활 기반 마련기'); // (16*2, 70*2)
            drawBuildingTypeE(120, 140, '가족 형성기'); // (60*2, 70*2)
            drawBuildingTypeF(220, 140, '자기계발/이직기'); // (110*2, 70*2)

            // Connect roads (8 pixels wide in grid units, same actual size as previous version)
            // Road coordinates adjusted for PIXEL_SIZE = 2 (original coords * 2)
            // Top Horizontal Road
            drawRoad(68, 104, 252, 104); // Y=52*2, X range (34*2 to 126*2)
            // Bottom Horizontal Road
            drawRoad(60, 204, 248, 204); // Y=102*2, X range (30*2 to 124*2)

            // Vertical Roads connecting buildings to horizontal roads (adjusted for new building sizes/positions)
            // B1 to Top Road
            drawRoad(68, 100, 68, 104); // From building edge to road
            // B2 to Top Road
            drawRoad(164, 100, 164, 104);
            // B3 to Top Road
            drawRoad(252, 120, 252, 104);

            // B4 to Bottom Road
            drawRoad(60, 188, 60, 204);
            // B5 to Bottom Road
            drawRoad(156, 196, 156, 204);
            // B6 to Bottom Road
            drawRoad(248, 188, 248, 204);

            // Vertical Roads connecting Top and Bottom Horizontal Roads
            drawRoad(68, 104, 68, 204); // Leftmost vertical connector
            drawRoad(164, 104, 164, 204); // Middle vertical connector
            drawRoad(252, 104, 252, 204); // Rightmost vertical connector
        }

        // Main animation loop
        function animate(currentTime) {
            drawMap(); // Redraw entire map each frame
            updateCharacterPosition(currentTime); // Update character position
            drawCharacter(); // Draw character on top
            requestAnimationFrame(animate); // Request next frame
        }

        // Show tooltip
        function showTooltip(x, y, text) {
            tooltip.innerText = text;
            tooltip.style.left = `${x + 10}px`;
            tooltip.style.top = `${y - 20}px`;
            tooltip.classList.add('active');
        }

        // Hide tooltip
        function hideTooltip() {
            tooltip.classList.remove('active');
        }

        // Mouse move event for tooltips
        canvas.addEventListener('mousemove', (event) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            const gridX = Math.floor(mouseX / PIXEL_SIZE);
            const gridY = Math.floor(mouseY / PIXEL_SIZE);

            let foundBuilding = false;
            for (const building of buildings) {
                if (gridX >= building.x && gridX < building.x + building.width &&
                    gridY >= building.y && gridY < building.y + building.height) {
                    showTooltip(event.clientX, event.clientY, building.name);
                    foundBuilding = true;
                    break;
                }
            }
            if (!foundBuilding) {
                hideTooltip();
            }
        });

        // Initial map drawing and animation loop start
        window.onload = () => {
            drawMap(); // Initial full map draw to populate mapGrid
            // Set initial character position on a valid road segment
            character.x = 72; // Near left vertical road
            character.y = 112; // On top horizontal road
            requestAnimationFrame(animate); // Start animation loop
        };

    </script>
</body>
</html>
